// oak build
__Oak_Modules := {}
__Oak_Import_Aliases := ?
fn __oak_modularize(name, module) __Oak_Modules.(name) := module
fn __oak_module_import(name) if ___runtime_lib?(name) {
	true -> import(name)
	_ -> if type(module := __Oak_Modules.(name)) {
		:null -> if module := __Oak_Modules.(__Oak_Import_Aliases.(name)) {
			? -> import(name)
			_ -> {
				mod := module()
				__Oak_Modules.(name) := mod
				mod
			}
		}
		:function -> {
			m := module()
			__Oak_Modules.(name) := m
			m
		}
		_ -> module
	}
}
(__oak_modularize('main.oak',fn()(std:=__oak_module_import('std'),str:=__oak_module_import('str'),{CowNode:CowNode}:=__oak_module_import('node.oak'),{CowError:CowError}:=__oak_module_import('util.oak'),static:=__oak_module_import('static.oak'),fn Soak(Env)Ctx:={Env:std.default(Env,static.Env),read:fn read(k)Env.(k),assg:fn assg(k,v)Env.(k)<-v,dele:fn dele(k)assg(k,?),Stack:[],add:fn add(v)Ctx.Stack<<v,pop:fn pop()(lastItem:=Ctx.Stack.(len(Ctx.Stack)-1),Ctx.Stack<-std.take(Ctx.Stack,len(Ctx.Stack)-1),lastItem),Steps:[],stepToNode:fn stepToNode(step)CowNode(step...),load:fn load(CowSteps)Ctx.Steps<-std.map(CowSteps,stepToNode),pack:fn pack()std.map(Ctx.Steps,fn(e)e.pack()),_parseInstruction:fn _parseInstruction(item)(items:=str.split(item.code,' '),operation:=Ctx.Env.(str.lower(items.0)),args:=std.slice(items,1),if type(operation){:function->operation(Ctx,{args:args,item:item,items:items}),:null->CowError('ParseError','Invalid instruction!',items.0,Ctx.Stack).throw()}),_jitStand:fn _jitStand(item)(next:=item.next(Ctx.Steps),if next !=?{true->_jitStep(next)}),_jitStep:fn _jitStep(item)(_parseInstruction(item),_jitStand(item)),_jitFirstStep:fn _jitFirstStep()(item:=std.find(Ctx.Steps,fn(step)step.thisReg=0),if item=-1{true->CowError('JIT','Failed to find first step!',pack(),Ctx.Stack).throw()},Ctx.Steps.(item)),jit:fn jit()(_jitStep(_jitFirstStep()),Ctx.Stack.(len(Ctx.Stack)-1))},{CowError:CowError,CowNode:CowNode,Soak:Soak,static:static,std:std,str:str})),__oak_modularize('node.oak',fn()(std:=__oak_module_import('std'),fn CowNode(code,thisReg,nextReg)Ctx:={thisReg:std.default(thisReg,0),nextReg:std.default(nextReg,0),code:std.default(code,''),pack:fn pack()[Ctx.code,Ctx.thisReg,Ctx.nextReg],_Next:fn _Next(step)step.thisReg=Ctx.nextReg,_Last:fn _Last(step)step.nextReg=Ctx.thisReg,_hasStep:fn _hasStep(steps,mutator)std.find(steps,mutator),_updateStep:fn _updateStep(steps,key,mutator)if Ctx.(key){?->Ctx.(key)<-steps.(_hasStep(steps,mutator)),_->Ctx.(key)},_findStep:fn _findStep(steps,key,mutator)(_updateStep(steps,key,mutator),Ctx.(key)),_nextStep?:?,_lastStep?:?,hasNext:fn hasNext(steps)_hasStep(steps,_Next),hasLast:fn hasLast(steps)_hasStep(steps,_Last),next:fn next(steps)_findStep(steps,'_nextStep?',_Next),last:fn last(steps)_findStep(steps,'_lastStep?',_Last),cache:fn cache(steps)[next(),last()],uncacheNext:fn uncacheNext()Ctx._nextStep?<-?,uncacheLast:fn uncacheLast()Ctx._lastStep?<-?,uncache:fn uncache()(uncacheNext(),uncacheLast())},{CowNode:CowNode,std:std})),__oak_modularize('static.oak',fn()(std:=__oak_module_import('std'),str:=__oak_module_import('str'),math:=__oak_module_import('math'),lower:='abcdefghijklmnopqrstuvwxyz',upper:='ABCDEFGHIJKLMNOPQRSTUVWXYZ',numbers:=[0,1,2,3,4,5,6,7,8,9],symbl:='#$%&*+-./:<=>?@^_`{|}~',bools:=[false,true],chars:=lower+upper+(str.join(std.map(numbers,string),''))+symbl,fn prim(ctx,obj)ctx.Soak.add(obj.(int(ctx.args.0))),Prims:={'t':fn(s,c)s.add(true),'f':fn(s,c)s.add(false),'#':fn(s,c)s.add(int(c.args.0)),'$':fn(s,c)s.add(c.args.0),'c-b':fn(s,c)prim(c,bools),'c-lw':fn(s,c)prim(c,lower),'c-up':fn(s,c)prim(c,upper),'c-al':fn(s,c)s.add(len(lower)),'c-nm':fn(s,c)prim(c,numbers),'c-nl':fn(s,c)s.add(len(numbers)),'c-sy':fn(s,c)prim(c,symbl),'c-sl':fn(s,c)s.add(len(symbl)),'c-cs':fn(s,c)prim(c,chars),'c-cl':fn(s,c)s.add(len(chars)),_ioarg:fn _ioarg(s,c,i,h)if val:=c.args.(i){?->s.pop(),_->std.default(h,string)(val)}},Adding:={qadd:fn(s,c)s.add(s.pop()+s.pop()),add:fn(s,c)s.add(_ioarg(s,c,0)+_ioarg(s,c,1))},Subtr:={qsub:fn(s,c)s.add(s.pop()-s.pop()),sub:fn(s,c)s.add(_ioarg(s,c,0)-_ioarg(s,c,1))},Mult:={qmlt:fn(s,c)s.add(s.pop()*s.pop()),mult:fn(s,c)s.add(_ioarg(s,c,0)*_ioarg(s,c,1)),_qd_b4:fn _qd_b4(x)pow(x,2)/4,_hkmlt:fn _hkmlt(a,b)_qd_b4(a+b)-_qd_b4(a-b),qhkmlt:fn(s,c)s.add(_hkmlt(s.pop(),s.pop())),hkmlt:fn(s,c)s.add(_hkmlt(_ioarg(s,c,0),_ioarg(s,c,1)))},Div:={div:fn(s,c)s.add(_ioarg(s,c,0)/_ioarg(s,c,1)),_exp:fn _exp(x)pow(math.E,x),exp:fn(s,c)s.add(_exp(s.pop())),_qdiv:fn _qdiv(a,b)(_exp(log(a)-log(b))),hkdiv:fn(s,c)s.add(_qdiv(_ioarg(s,c,0),_ioarg(s,c,1))),qhkdiv:fn(s,c)s.add(_qdiv(s.pop(),s.pop()))},Pow:={pow:fn(s,c)s.add(pow(_ioarg(s,c,0),_ioarg(s,c,1))),qpow:fn(s,c)s.add(pow(s.pop(),s.pop())),_hkpow:fn _hkpow(a,b)if b{0->1,_->_hkmlt(a,_hkpow(a,b-1))},qhkpow:fn(s,c)s.add(_hkpow(s.pop(),s.pop())),hkpow:fn(s,c)s.add(_hkpow(_ioarg(s,c,0),_ioarg(s,c,1)))},Math:=std.merge(Adding,Subtr,Mult,Div,Pow),Env:=std.merge(Prims,Math,{}),{Adding:Adding,Div:Div,Env:Env,Math:Math,Mult:Mult,Pow:Pow,Prims:Prims,Subtr:Subtr,_exp:_exp,_hkmlt:_hkmlt,_hkpow:_hkpow,_ioarg:_ioarg,_qd_b4:_qd_b4,_qdiv:_qdiv,bools:bools,chars:chars,lower:lower,math:math,numbers:numbers,prim:prim,std:std,str:str,symbl:symbl,upper:upper})),__oak_modularize('util.oak',fn()(std:=__oak_module_import('std'),fmt:=__oak_module_import('fmt'),fn CowError(name,message,cause,stack)(Ctx:={name:std.default(name,''),cause:std.default(cause,?),stack:std.default(stack,''),message:std.default(message,''),throw:fn(args...)(std.println(fmt.format('{{0}} -> {{1}}:',Ctx.name,Ctx.message)),std.println(' ',Ctx.cause),std.println(' ',Ctx.stack),exit(1))}),{CowError:CowError,fmt:fmt,std:std})),__Oak_Import_Aliases<-{},__oak_module_import('main.oak'))