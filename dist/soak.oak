// oak build
__Oak_Modules := {}
__Oak_Import_Aliases := ?
fn __oak_modularize(name, module) __Oak_Modules.(name) := module
fn __oak_module_import(name) if ___runtime_lib?(name) {
	true -> import(name)
	_ -> if type(module := __Oak_Modules.(name)) {
		:null -> if module := __Oak_Modules.(__Oak_Import_Aliases.(name)) {
			? -> import(name)
			_ -> {
				mod := module()
				__Oak_Modules.(name) := mod
				mod
			}
		}
		:function -> {
			m := module()
			__Oak_Modules.(name) := m
			m
		}
		_ -> module
	}
}
(__oak_modularize('src/main.oak',fn()(std:=__oak_module_import('std'),str:=__oak_module_import('str'),cli:=__oak_module_import('cli'),static:=__oak_module_import('src/static.oak'),{CowNode:CowNode}:=__oak_module_import('src/node.oak'),{CowError:CowError}:=__oak_module_import('src/util.oak'),fn Soak(Env)Ctx:={Env:std.default(Env,static.Env),read:fn read(k)Env.(k),assg:fn assg(k,v)Env.(k)<-v,dele:fn dele(k)assg(k,?),Stack:[],add:fn add(v)Ctx.Stack<<v,ins:fn ins(v)std.append([v],Ctx.Stack),peek:fn peek()Ctx.Stack.(len(Ctx.Stack)-1),pop:fn pop()(lastItem:=Ctx.Stack.(len(Ctx.Stack)-1),Ctx.Stack<-std.take(Ctx.Stack,len(Ctx.Stack)-1),lastItem),shuf:fn shuf()(ins(pop())),rshuf:fn rshuf()(add(shift())),shift:fn shift()(firstItem:=Ctx.Stack.0,Ctx.Stack<-std.slice(Ctx.Stack,1),firstItem),drop:fn drop()(Ctx.Stack<-std.take(Ctx.Stack,len(Ctx.Stack)-1)),dup:fn dup()Ctx.Stack<<peek(),swap:fn swap()(topItem:=pop(),secondItem:=pop(),add(topItem),add(secondItem)),over:fn over()(secondItem:=Ctx.Stack.(len(Ctx.Stack)-2),Ctx.Stack<<secondItem),rot:fn rot()(a:=pop(),b:=pop(),c:=pop(),add(a),add(c),add(b)),rotcc:fn rotcc()(a:=pop(),b:=pop(),c:=pop(),add(b),add(a),add(c)),Steps:[],clr:fn clr()Ctx.Steps<-[],stepToNode:fn stepToNode(step)CowNode(step...),load:fn load(CowSteps)Ctx.Steps<-std.map(CowSteps,stepToNode),pack:fn pack()std.map(Ctx.Steps,fn(e)e.pack()),_getInst:fn _getInst(i)Ctx.Env.(str.lower(i)),_parseInstruction:fn _parseInstruction(item)(items:=str.split(item.code,' '),operation:=_getInst(items.0),args:=std.slice(items,1),if type(operation){:function->operation(Ctx,{args:args,items:items,item:item}),:null->CowError('ParseError','Invalid instruction!',items.0,Ctx.Stack).throw()}),Registry:{},setVar:fn setVar(register,value)(Ctx.Registry.(register)<-value),delVar:fn delVar(register,value)setVar(register,?),_jitStand:fn _jitStand(item)(next:=item.next(Ctx.Steps),if next !=?{true->_jitStep(next)}),_jitStep:fn _jitStep(item)(_parseInstruction(item),_jitStand(item)),_jitFirstStep:fn _jitFirstStep()(item:=std.find(Ctx.Steps,fn(step)step.thisReg=0),if item=-1{true->CowError('JIT','Failed to find first step!',pack(),Ctx.Stack).throw()},Ctx.Steps.(item)),jit:fn jit()(_jitStep(_jitFirstStep()),Ctx.Stack.(len(Ctx.Stack)-1)),loJit:fn loJit(CowSteps)(load(CowSteps),jit()),newLoJit:fn newLoJit(CowSteps)Soak().loJit(CowSteps)},Cli:=cli.parse(),if Cli.verb{fn CliFull()(codes:=[],args:=std.clone(Cli.args),fn recurse()(codes<<[args.2,int(args.0),int(args.1)],args<-std.takeLast(args,len(args)-3),if len(args)>=3{true->recurse()}),recurse(),std.println(Soak().newLoJit(codes)))->CliFull(),fn CliSemi()(codes:=[],args:=std.clone(Cli.args),x:=0,z:=0,fn recurse()(codes<<[args.0,x<-z,z<-z+1],args<-std.takeLast(args,len(args)-1),if len(args)>=1{true->recurse()}),recurse(),std.println(Soak().newLoJit(codes)))->CliFull(),'full'->CliFull(),'semi'->CliSemi()},{Cli:Cli,CliFull:CliFull,CliSemi:CliSemi,CowError:CowError,CowNode:CowNode,Soak:Soak,cli:cli,static:static,std:std,str:str})),__oak_modularize('src/node.oak',fn()(std:=__oak_module_import('std'),fn CowNode(code,thisReg,nextReg)Ctx:={code:std.default(code,''),thisReg:std.default(thisReg,0),nextReg:std.default(nextReg,1),pack:fn pack()[Ctx.code,Ctx.thisReg,Ctx.nextReg],_Next:fn _Next(step)step.thisReg=Ctx.nextReg,_Last:fn _Last(step)step.nextReg=Ctx.thisReg,_hasStep:fn _hasStep(steps,mutator)std.find(steps,mutator),_updateStep:fn _updateStep(steps,key,mutator)if Ctx.(key){?->Ctx.(key)<-steps.(_hasStep(steps,mutator)),_->Ctx.(key)},_findStep:fn _findStep(steps,key,mutator)(_updateStep(steps,key,mutator),Ctx.(key)),_nextStep?:?,_lastStep?:?,hasNext:fn hasNext(steps)_hasStep(steps,_Next),hasLast:fn hasLast(steps)_hasStep(steps,_Last),next:fn next(steps)_findStep(steps,'_nextStep?',_Next),last:fn last(steps)_findStep(steps,'_lastStep?',_Last),cache:fn cache(steps)[next(),last()],uncacheNext:fn uncacheNext()Ctx._nextStep?<-?,uncacheLast:fn uncacheLast()Ctx._lastStep?<-?,uncache:fn uncache()(uncacheNext(),uncacheLast())},{CowNode:CowNode,std:std})),__oak_modularize('src/static.oak',fn()(std:=__oak_module_import('std'),str:=__oak_module_import('str'),math:=__oak_module_import('math'),{MemCache:MemCache}:=__oak_module_import('src/structures/MemCache.oak'),lower:='abcdefghijklmnopqrstuvwxyz',upper:='ABCDEFGHIJKLMNOPQRSTUVWXYZ',numbers:=[0,1,2,3,4,5,6,7,8,9],symbl:='#$%&*+-./:<=>?@^_`{|}~',bools:=[false,true],chars:=lower+upper+(str.join(std.map(numbers,string),''))+symbl,fn prim(ctx,obj)ctx.Soak.add(obj.(int(ctx.args.0))),Prims:={'t':fn(s,c)s.add(true),'f':fn(s,c)s.add(false),'#':fn(s,c)s.add(int(c.args.0)),'$':fn(s,c)s.add(c.args.0),'@':fn Goto(s,c)c.item.nextReg<-int(c.args.0),'^':fn(s,c)fn()Goto(s,c),'c-b':fn(s,c)prim(c,bools),'c-lw':fn(s,c)prim(c,lower),'c-up':fn(s,c)prim(c,upper),'c-al':fn(s,c)s.add(len(lower)),'c-nm':fn(s,c)prim(c,numbers),'c-nl':fn(s,c)s.add(len(numbers)),'c-sy':fn(s,c)prim(c,symbl),'c-sl':fn(s,c)s.add(len(symbl)),'c-cs':fn(s,c)prim(c,chars),'c-cl':fn(s,c)s.add(len(chars)),_ioarg:fn _ioarg(s,c,i,h,p)if val:=c.args.(i){?->s.(std.default(p,'pop'))(),_->std.default(h,string)(val)}},Stack:={drop:fn(s,c)s.drop(),dup:fn(s,c)s.dup(),swap:fn(s,c)s.swap(),over:fn(s,c)s.over(),rot:fn(s,c)s.rot(),rotcc:fn(s,c)s.rotcc(),shuf:fn(s,c)s.shuf(),rshuf:fn(s,c)s.rshuf()},Adding:={qadd:fn(s,c)s.add(s.pop()+s.pop()),_intOrFloat:fn _intOrFloat(v)if v:=int(v){?->float(v),_->v},add:fn(s,c)s.add(_ioarg(s,c,0,_intOrFloat)+_ioarg(s,c,1,_intOrFloat))},Subtr:={qsub:fn(s,c)s.add(s.pop()-s.pop()),sub:fn(s,c)s.add(_ioarg(s,c,0,_intOrFloat)-_ioarg(s,c,1,_intOrFloat))},Mult:={qmlt:fn(s,c)s.add(s.pop()*s.pop()),mlt:fn(s,c)s.add(_ioarg(s,c,0,_intOrFloat)*_ioarg(s,c,1,_intOrFloat)),_qd_b4:fn _qd_b4(x)pow(x,2)/4,_hkmlt:fn _hkmlt(a,b)_qd_b4(a+b)-_qd_b4(a-b),qhkmlt:fn(s,c)s.add(_hkmlt(s.pop(),s.pop())),hkmlt:fn(s,c)s.add(_hkmlt(_ioarg(s,c,0,_intOrFloat),_ioarg(s,c,1,_intOrFloat)))},Div:={div:fn(s,c)s.add(_ioarg(s,c,0,_intOrFloat)/_ioarg(s,c,1,_intOrFloat)),_exp:fn _exp(x)pow(math.E,x),exp:fn(s,c)s.add(_exp(s.pop())),_qdiv:fn _qdiv(a,b)(_exp(log(a)-log(b))),hkdiv:fn(s,c)s.add(_qdiv(_ioarg(s,c,0,_intOrFloat),_ioarg(s,c,1,_intOrFloat))),qhkdiv:fn(s,c)s.add(_qdiv(s.pop(),s.pop()))},Pow:={pow:fn(s,c)s.add(pow(_ioarg(s,c,0,_intOrFloat),_ioarg(s,c,1,_intOrFloat))),qpow:fn(s,c)s.add(pow(s.pop(),s.pop())),_hkpow:fn _hkpow(a,b)if b{0->1,_->_hkmlt(a,_hkpow(a,b-1))},qhkpow:fn(s,c)s.add(_hkpow(s.pop(),s.pop())),hkpow:fn(s,c)s.add(_hkpow(_ioarg(s,c,0,_intOrFloat),_ioarg(s,c,1,_intOrFloat)))},Mod:={qmod:fn(s,c)s.add(s.pop()%s.pop()),mod:fn(s,c)s.add(_ioarg(s,c,0)%_ioarg(s,c,1))},Trig:={sin:fn(s,c)s.add(sin(_ioarg(s,c,0,_intOrFloat))),qsin:fn(s,c)s.add(sin(s.pop())),cos:fn(s,c)s.add(cos(_ioarg(s,c,0,_intOrFloat))),qcos:fn(s,c)s.add(cos(s.pop())),tan:fn(s,c)s.add(tan(_ioarg(s,c,0,_intOrFloat))),qtan:fn(s,c)s.add(tan(s.pop()))},Sqrt:={qsqrt:fn(s,c)s.add(math.sqrt(s.pop())),sqrt:fn(s,c)s.add(math.sqrt(_ioarg(s,c,0,_intOrFloat))),_hksqrt:fn _hksqrt(n)if n>=0{true->_hkpow(n,0.5)},hksqrt:fn(s,c)s.add(_hksqrt(_ioarg(s,c,0,_intOrFloat))),qhksqrt:fn(s,c)s.add(_hksqrt(s.pop()))},Abs:={abs:fn(s,c)s.add(math.abs(_ioarg(s,c,0,_intOrFloat))),qabs:fn(s,c)s.add(math.abs(s.pop())),hkabs:fn(s,c)s.add(_hksqrt(_hkpow(_ioarg(s,c,0,_intOrFloat),2))),qhkabs:fn(s,c)s.add(_hksqrt(_hkpow(s.pop(),2)))},Bitwise:={band:fn(s,c)s.add(_ioarg(s,c,0,_intOrFloat)&_ioarg(s,c,1,_intOrFloat)),qband:fn(s,c)s.add(s.pop()&s.pop()),bor:fn(s,c)s.add(_ioarg(s,c,0,_intOrFloat)|_ioarg(s,c,1,_intOrFloat)),qbor:fn(s,c)s.add(s.pop()|s.pop()),bxor:fn(s,c)s.add(_ioarg(s,c,0,_intOrFloat)^_ioarg(s,c,1,_intOrFloat)),qbxor:fn(s,c)s.add(s.pop()^s.pop()),qlshift:fn(s,c)(positions:=s.pop(),value:=s.pop(),result:=value*pow(2,positions),s.add(result)),lshift:fn(s,c)(value:=_ioarg(s,c,0,_intOrFloat),positions:=_ioarg(s,c,1,_intOrFloat),result:=value*pow(2,positions),s.add(result)),qrshift:fn(s,c)(positions:=s.pop(),value:=s.pop(),result:=value/pow(2,positions),s.add(result)),rshift:fn(s,c)(value:=_ioarg(s,c,0,_intOrFloat),positions:=_ioarg(s,c,1,_intOrFloat),result:=value/pow(2,positions),s.add(result)),hklshift:fn(s,c)(value:=_ioarg(s,c,0,_intOrFloat),positions:=_ioarg(s,c,1,_intOrFloat),result:=_hkmlt(value,_hkpow(2,positions)),s.add(result)),qhklshift:fn(s,c)(positions:=s.pop(),value:=s.pop(),result:=_hkmlt(value,_hkpow(2,positions)),s.add(result)),hkrshift:fn(s,c)(value:=_ioarg(s,c,0,_intOrFloat),positions:=_ioarg(s,c,1,_intOrFloat),result:=value/_hkpow(2,positions),s.add(result)),qhkrshift:fn(s,c)(positions:=s.pop(),value:=s.pop(),result:=value/_hkpow(2,positions),s.add(result))},Hex:={fromhex:fn(s,c)s.add(std.fromHex(_ioarg(s,c,0,string))),tohex:fn(s,c)s.add(std.toHex(_ioarg(s,c,0,int)))},Math:=std.merge(Adding,Subtr,Mult,Div,Pow,Mod,Trig,Sqrt,Abs,Bitwise,Hex),BoolOps:={_bool:fn(a)if a{true->true,1->true,false->false,0->false},eq:fn(s,c)s.add(_ioarg(s,c,0,_bool)=_ioarg(s,c,1,_bool)),qeq:fn(s,c)s.add(s.pop()=s.pop()),neq:fn(s,c)s.add(_ioarg(s,c,0,_bool) !=_ioarg(s,c,1,_bool)),qneq:fn(s,c)s.add(s.pop() !=s.pop()),not:fn(s,c)s.add(!_ioarg(s,c,0,_bool)),qnot:fn(s,c)s.add(!s.pop())},MemOps:={MemCache:MemCache(),mc_addctx:fn(s,c)(newCtx:=_ioarg(s,c,0,string),MemOps.MemCache.addCtx(newCtx)),mc_hasctx:fn(s,c)(ctx:=_ioarg(s,c,0,string),s.add(MemOps.MemCache.hasCtxAt(ctx) !=-1)),mc_getctx:fn(s,c)(ctx:=_ioarg(s,c,0,string),s.add(MemOps.MemCache.getCtx(ctx))),mc_newctx:fn(s,c)(ctx:=_ioarg(s,c,0,string),newData:=s.pop(),MemOps.MemCache.updateCtx(ctx,newData)),mc_delctx:fn(s,c)(ctx:=_ioarg(s,c,0,string),MemOps.MemCache.delCtx(ctx)),mc_gc:fn(s,c)(MemOps.MemCache.gc()),mc_setkey:fn(s,c)(ctx:=_ioarg(s,c,0,string),key:=_ioarg(s,c,1,string),value:=s.pop(),MemOps.MemCache.setKey(ctx,key,value)),mc_getkey:fn(s,c)(ctx:=_ioarg(s,c,0,string),key:=_ioarg(s,c,1,string),s.add(MemOps.MemCache.getKey(ctx,key))),mc_haskey:fn(s,c)(ctx:=_ioarg(s,c,0,string),key:=_ioarg(s,c,1,string),s.add(MemOps.MemCache.hasKey(ctx,key) !=null)),pick:fn(s,c)(n:=_ioarg(s,c,0,int),s.add(s.Stack.(len(s.Stack)-1-n))),store:fn(s,c)(key:=_ioarg(s,c,0),value:=s.pop(),s.Registry.(key)<-value),load:fn(s,c)(key:=_ioarg(s,c,0),s.add(s.Registry.(key)))},CastOps:={toint:fn(s,c)s.add(int(_ioarg(s,c,0))),tostr:fn(s,c)s.add(string(_ioarg(s,c,0))),tobool:fn(s,c)s.add(bool(_ioarg(s,c,0))),tofloat:fn(s,c)s.add(float(_ioarg(s,c,0)))},StringOps:={concat:fn(s,c)s.add(_ioarg(s,c,0,string)<<_ioarg(s,c,1,string)),substr:fn(s,c)(str:=_ioarg(s,c,0,string),start:=_ioarg(s,c,1,int),end:=_ioarg(s,c,2,int),s.add(str.substring(start,end))),length:fn(s,c)s.add(len(_ioarg(s,c,0,string)))},ListOps:={map:fn(s,c)(list:=_ioarg(s,c,0),func:=s.pop(),s.add(std.map(list,func))),filter:fn(s,c)(list:=_ioarg(s,c,0),func:=s.pop(),s.add(std.filter(list,func))),reduce:fn(s,c)(list:=_ioarg(s,c,0),func:=s.pop(),initial:=_ioarg(s,c,1),s.add(std.reduce(list,func,initial)))},ControlFlow:={'if':fn(s,c)(condition:=s.pop(),true_branch:=s.pop(),false_branch:=s.pop(),result:=if condition{true->true_branch(),_->false_branch()},s.add(result)),loop:fn(s,c)(condition:=s.pop(),body:=s.pop(),std.loop(body))},Memoization:={_cache:{},_get_or_compute:fn _get_or_compute(key,func,args)if Memoization._cache.(key){?->func(args...),cached->cached},memoize:fn(s,c)(func:=s.pop(),fn memoized(args...)(key:=str.join(',',args),result:=_get_or_compute(key,func,args),Memoization._cache.(key)<-result,result),s.add(memoized)),clear_cache:fn(s,c)(Memoization._cache<-{})},Jump:={jump:fn jump(s,c)c.item.nextReg<-_ioarg(s,c,0,int),jmif:fn(s,c)if _ioarg(s,c,0,int,'peek'){false->jump(s,c),0->jump(s,c)},subrt:fn(s,c)(index:=std.find(s.Steps,fn(step)step=_ioarg(s,c,0,int)),s._jitStep(s.Steps.(index)))},Importing:={std:fn(s,c)(module:=_ioarg(s,c,0,string),imported:=__oak_module_import(module),s.add(imported))},PropAccess:={access:fn access(s,c)(obj:=_ioarg(s,c,0),prop:=_ioarg(s,c,1,string),s.add(obj.(prop)))},Env:=std.merge(Prims,Math,BoolOps,StringOps,ListOps,CastOps,MemOps,Jump,ControlFlow,Memoization,Importing,PropAccess),{Abs:Abs,Adding:Adding,Bitwise:Bitwise,BoolOps:BoolOps,CastOps:CastOps,ControlFlow:ControlFlow,Div:Div,Env:Env,Goto:Goto,Hex:Hex,Importing:Importing,Jump:Jump,ListOps:ListOps,Math:Math,MemCache:MemCache,MemOps:MemOps,Memoization:Memoization,Mod:Mod,Mult:Mult,Pow:Pow,Prims:Prims,PropAccess:PropAccess,Sqrt:Sqrt,Stack:Stack,StringOps:StringOps,Subtr:Subtr,Trig:Trig,_exp:_exp,_get_or_compute:_get_or_compute,_hkmlt:_hkmlt,_hkpow:_hkpow,_hksqrt:_hksqrt,_intOrFloat:_intOrFloat,_ioarg:_ioarg,_qd_b4:_qd_b4,_qdiv:_qdiv,access:access,bools:bools,chars:chars,jump:jump,lower:lower,math:math,numbers:numbers,prim:prim,std:std,str:str,symbl:symbl,upper:upper})),__oak_modularize('src/structures/MemCache.oak',fn()(std:=__oak_module_import('std'),fn MemCache()Ctx:={store:[],addCtx:fn addCtx(NewCx)Ctx.store<<[NewCx,{}],hasCtxAt:fn hasCtxAt(Cx)std.find(Ctx.store,fn(store)store.0=Cx),getCtx:fn getCtx(Cx)Ctx.store.(hasCtxAt(Cx)),updateCtx:fn updateCtx(Cx,NewData)Ctx.store.(hasCtxAt(Cx))<-[Cx,NewData],setKey:fn setKey(Cx,Key,Value)(ind:=hasCtxAt(Cx),if ind !=-1{true->(Ctx.store.(ind).1).(Key)<-Value}),getKey:fn getKey(Cx,Key)(ind:=hasCtxAt(Cx),if ind !=-1{true->(Ctx.store.(ind).1).(Key)}),hasKey:fn hasKey(Cx,Key)(ind:=hasCtxAt(Cx),if ind !=-1{true->std.find(keys(Ctx.store.(ind).1),fn(i)i=Key)}),delCtx:fn delCtx(Cx)(ind:=hasCtxAt(Cx),Ctx.store<-std.merge(std.slice(Ctx.store,0,ind-1),std.slice(Ctx.store,ind+1))),gc:fn()Ctx.store<-[]},{MemCache:MemCache,std:std})),__oak_modularize('src/util.oak',fn()(std:=__oak_module_import('std'),fmt:=__oak_module_import('fmt'),fn CowError(name,message,cause,stack)(Ctx:={name:std.default(name,''),cause:std.default(cause,?),stack:std.default(stack,''),message:std.default(message,''),throw:fn(args...)(std.println(fmt.format('{{0}} -> {{1}}:',Ctx.name,Ctx.message)),std.println(' ',Ctx.cause),std.println(' ',Ctx.stack),exit(1))}),{CowError:CowError,fmt:fmt,std:std})),__Oak_Import_Aliases<-{'std':'std.oak','str':'str.oak','math':'math.oak','sort':'sort.oak','random':'random.oak','fs':'fs.oak','fmt':'fmt.oak','json':'json.oak','datetime':'datetime.oak','path':'path.oak','http':'http.oak','test':'test.oak','debug':'debug.oak','cli':'cli.oak','md':'md.oak','crypto':'crypto.oak','syntax':'syntax.oak'},__oak_module_import('src/main.oak'))